{"version":3,"file":"component---src-pages-markdown-remark-frontmatter-slug-tsx-14986d819f72e6b68531.js","mappings":"yMA4CO,SAASA,EAASC,EAAUC,GACjC,MAAMC,EAAc,KAAM,OAAcD,GAASE,GAAIC,KAE/CC,EAAmBJ,GAASI,kBAAoB,EAChDC,EAsDR,SAAyBC,GACvB,MAAMD,EAAc,CAAC,EACfE,EAAQD,EAAWE,MAAMC,EAASC,mBACxC,IAAIC,EAIJ,GAAIJ,EAAMK,OAAS,EACjB,OAAOP,EAGL,IAAIQ,KAAKN,EAAM,IACjBI,EAAaJ,EAAM,IAEnBF,EAAYS,KAAOP,EAAM,GACzBI,EAAaJ,EAAM,GACfE,EAASM,kBAAkBF,KAAKR,EAAYS,QAC9CT,EAAYS,KAAOR,EAAWE,MAAMC,EAASM,mBAAmB,GAChEJ,EAAaL,EAAWU,OACtBX,EAAYS,KAAKF,OACjBN,EAAWM,UAKjB,GAAID,EAAY,CACd,MAAMM,EAAQR,EAASS,SAASC,KAAKR,GACjCM,GACFZ,EAAYe,KAAOT,EAAWU,QAAQJ,EAAM,GAAI,IAChDZ,EAAYa,SAAWD,EAAM,IAE7BZ,EAAYe,KAAOT,CAEvB,CAEA,OAAON,CACT,CA1FsBiB,CAAgBvB,GAEpC,IAAIe,EACJ,GAAIT,EAAYS,KAAM,CACpB,MAAMS,EAwFV,SAAmBjB,EAAYF,GAC7B,MAAMoB,EAAQ,IAAIC,OAChB,wBACG,EAAIrB,GACL,uBACC,EAAIA,GACL,QAGEsB,EAAWpB,EAAWqB,MAAMH,GAElC,IAAKE,EAAU,MAAO,CAAEE,KAAMzB,IAAK0B,eAAgB,IAEnD,MAAMD,EAAOF,EAAS,GAAKI,SAASJ,EAAS,IAAM,KAC7CK,EAAUL,EAAS,GAAKI,SAASJ,EAAS,IAAM,KAGtD,MAAO,CACLE,KAAkB,OAAZG,EAAmBH,EAAiB,IAAVG,EAChCF,eAAgBvB,EAAW0B,OAAON,EAAS,IAAMA,EAAS,IAAId,QAElE,CA7G4BqB,CAAU5B,EAAYS,KAAMV,GACpDU,EA8GJ,SAAmBR,EAAYsB,GAE7B,GAAa,OAATA,EAAe,OAAO,IAAIM,KAAK/B,KAEnC,MAAMuB,EAAWpB,EAAWqB,MAAMQ,GAElC,IAAKT,EAAU,OAAO,IAAIQ,KAAK/B,KAE/B,MAAMiC,IAAeV,EAAS,GACxBW,EAAYC,EAAcZ,EAAS,IACnCa,EAAQD,EAAcZ,EAAS,IAAM,EACrCc,EAAMF,EAAcZ,EAAS,IAC7Be,EAAOH,EAAcZ,EAAS,IAC9BgB,EAAYJ,EAAcZ,EAAS,IAAM,EAE/C,GAAIU,EACF,OA0FJ,SAA0BO,EAAOF,EAAMD,GACrC,OAAOC,GAAQ,GAAKA,GAAQ,IAAMD,GAAO,GAAKA,GAAO,CACvD,CA5FSI,CAAiBhB,EAAMa,EAAMC,GA2DtC,SAA0BG,EAAaJ,EAAMD,GAC3C,MAAM1B,EAAO,IAAIoB,KAAK,GACtBpB,EAAKgC,eAAeD,EAAa,EAAG,GACpC,MAAME,EAAqBjC,EAAKkC,aAAe,EACzCC,EAAoB,GAAZR,EAAO,GAASD,EAAM,EAAIO,EAExC,OADAjC,EAAKoC,WAAWpC,EAAKqC,aAAeF,GAC7BnC,CACT,CA/DWsC,CAAiBxB,EAAMa,EAAMC,GAF3B,IAAIR,KAAK/B,KAGb,CACL,MAAMW,EAAO,IAAIoB,KAAK,GACtB,OAuEJ,SAAsBN,EAAMW,EAAOzB,GACjC,OACEyB,GAAS,GACTA,GAAS,IACTzB,GAAQ,GACRA,IAASuC,EAAad,KAAWe,EAAgB1B,GAAQ,GAAK,IAElE,CA7EO2B,CAAa3B,EAAMW,EAAOC,IA+EjC,SAA+BZ,EAAMS,GACnC,OAAOA,GAAa,GAAKA,IAAciB,EAAgB1B,GAAQ,IAAM,IACvE,CAhFO4B,CAAsB5B,EAAMS,IAI/BvB,EAAKgC,eAAelB,EAAMW,EAAOkB,KAAKC,IAAIrB,EAAWG,IAC9C1B,GAHE,IAAIoB,KAAK/B,IAIpB,CACF,CA7IWwD,CAAUpC,EAAgBM,eAAgBN,EAAgBK,KACnE,CAEA,IAAKd,GAAQ8C,OAAO9C,GAAO,OAAOb,IAElC,MAAM4D,GAAa/C,EACnB,IACIgD,EADA1C,EAAO,EAGX,GAAIf,EAAYe,OACdA,EAyIJ,SAAmBT,GACjB,MAAMe,EAAWf,EAAWgB,MAAMoC,GAClC,IAAKrC,EAAU,OAAOvB,IAEtB,MAAM6D,EAAQC,EAAcvC,EAAS,IAC/BwC,EAAUD,EAAcvC,EAAS,IACjCyC,EAAUF,EAAcvC,EAAS,IAEvC,IAiEF,SAAsBsC,EAAOE,EAASC,GACpC,GAAc,KAAVH,EACF,OAAmB,IAAZE,GAA6B,IAAZC,EAG1B,OACEA,GAAW,GACXA,EAAU,IACVD,GAAW,GACXA,EAAU,IACVF,GAAS,GACTA,EAAQ,EAEZ,CA9EOI,CAAaJ,EAAOE,EAASC,GAChC,OAAOhE,IAGT,OACE6D,EAAQ,KAAqBE,EAAU,KAAiC,IAAVC,CAElE,CAxJWE,CAAUhE,EAAYe,MACzBwC,MAAMxC,IAAO,OAAOnB,IAG1B,IAAII,EAAYa,SAGT,CACL,MAAMoD,EAAU,IAAIpC,KAAK2B,EAAYzC,GAC/BmD,GAAS,OAAO,EAAGvE,GAASE,IAYlC,OAXAqE,EAAOC,YACLF,EAAQG,iBACRH,EAAQI,cACRJ,EAAQnB,cAEVoB,EAAOI,SACLL,EAAQM,cACRN,EAAQO,gBACRP,EAAQQ,gBACRR,EAAQS,sBAEHR,CACT,CAhBE,OADAT,EAyJJ,SAAuBkB,GACrB,GAAuB,MAAnBA,EAAwB,OAAO,EAEnC,MAAMtD,EAAWsD,EAAerD,MAAMsD,GACtC,IAAKvD,EAAU,OAAO,EAEtB,MAAMwD,EAAuB,MAAhBxD,EAAS,IAAc,EAAI,EAClCsC,EAAQlC,SAASJ,EAAS,IAC1BwC,EAAWxC,EAAS,IAAMI,SAASJ,EAAS,KAAQ,EAE1D,IAyDF,SAA0ByD,EAAQjB,GAChC,OAAOA,GAAW,GAAKA,GAAW,EACpC,CA3DOkB,CAAiBpB,EAAOE,GAC3B,OAAO/D,IAGT,OAAO+E,GAAQlB,EAAQ,KAAqBE,EAAU,KACxD,CAxKamB,CAAchF,EAAYa,UAC/B0C,MAAME,GAAgB7D,KAkBrB,OAAO4D,EAAYzC,EAAO0C,EAAQ9D,GAASE,GACpD,CAEA,MAAMO,EAAW,CACfC,kBAAmB,OACnBK,kBAAmB,QACnBG,SAAU,cAGNiB,EACJ,gEACI4B,EACJ,4EACIkB,EAAgB,gCAgGtB,SAAS3C,EAAcgD,GACrB,OAAOA,EAAQxD,SAASwD,GAAS,CACnC,CAmBA,SAASrB,EAAcqB,GACrB,OAAQA,GAASC,WAAWD,EAAMjE,QAAQ,IAAK,OAAU,CAC3D,CA+BA,MAAMgC,EAAe,CAAC,GAAI,KAAM,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAEpE,SAASC,EAAgB1B,GACvB,OAAOA,EAAO,KAAQ,GAAMA,EAAO,GAAM,GAAKA,EAAO,KAAQ,CAC/D,C,wJCzMuB6B,KAAK+B,IAAI,GAAI,GA/B7B,MAoEMC,EAAuB,IAOvBC,EAAqB,KAqBrBC,EAAiB,MAOjBC,EAAe,KA0FfC,EAAsBC,OAAOC,IAAI,oB,uBCvNvC,SAASC,EAAgBC,EAAQC,GAGtC,OAFaD,EAAS,EAAI,IAAM,IACjBxC,KAAK0C,IAAIF,GAAQG,WAAWC,SAASH,EAAc,IAEpE,CC4BO,SAASI,EAAOhB,GACrB,OACEA,aAAiBpD,MACC,iBAAVoD,GACoC,kBAA1CiB,OAAOC,UAAUJ,SAASK,KAAKnB,EAErC,C,gCAGA,I,UCPO,SAASoB,EAAQ5F,GACtB,SAAWwF,EAAOxF,IAAyB,iBAATA,GAAsB8C,QAAO,EAAA+C,EAAA,GAAO7F,IACxE,CChCA,MAAM8F,EAAO,CAAC,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,OAElDC,EAAS,CACb,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OAuBK,SAASC,EAAchG,GAC5B,MAAMiG,GAAQ,EAAAJ,EAAA,GAAO7F,GAErB,IAAK4F,EAAQK,GACX,MAAM,IAAIC,WAAW,sBAavB,MAAO,GAVSJ,EAAKG,EAAM/D,iBACRgD,EAAgBe,EAAM5D,aAAc,MACrC0D,EAAOE,EAAMrC,kBAClBqC,EAAMtC,oBAENuB,EAAgBe,EAAMnC,cAAe,MACnCoB,EAAgBe,EAAMlC,gBAAiB,MACvCmB,EAAgBe,EAAMjC,gBAAiB,QAIxD,C,qECtBO,SAASmC,EAAcnG,EAAMwE,GAClC,MAAoB,mBAATxE,EAA4BA,EAAKwE,GAExCxE,GAAwB,iBAATA,GAAqB,QAAuBA,EACtDA,EAAK,MAAqBwE,GAE/BxE,aAAgBoB,KAAa,IAAIpB,EAAKoG,YAAY5B,GAE/C,IAAIpD,KAAKoD,EAClB,C,wJCvCO,MAAM6B,EAAYC,EAAAA,QAAOC,IAAGC,WAAA,CAAAC,YAAA,8BAAAC,YAAA,gBAAVJ,CAAU,MAEtBK,EAAeL,EAAAA,QAAOC,IAAGC,WAAA,CAAAC,YAAA,iCAAAC,YAAA,gBAAVJ,CAAU,qJAE3BM,EAAAA,EAAOC,MAAMC,UAGTF,EAAAA,EAAOG,SAASC,GACdJ,EAAAA,EAAOK,WAAWC,MAE/BC,EAAAA,EAAMC,YAAYC,GAAG,MACRT,EAAAA,EAAOG,SAASO,GAI7BH,EAAAA,EAAMC,YAAYC,GAAG,OAKZE,GAAYjB,EAAAA,EAAAA,SAAOkB,EAAAA,IAAUhB,WAAA,CAAAC,YAAA,8BAAAC,YAAA,gBAAjBJ,CAAiB,MAE7BmB,EAAWnB,EAAAA,QAAOoB,MAAKlB,WAAA,CAAAC,YAAA,6BAAAC,YAAA,gBAAZJ,CAAY,+CAGzBM,EAAAA,EAAOC,MAAMc,WAGXC,GAAetB,EAAAA,EAAAA,SAAOuB,EAAAA,IAAWC,MAAM,CAClDC,GAAI,YACJvB,WAAA,CAAAC,YAAA,iCAAAC,YAAA,gBAF0BJ,CAE1B,MAEW0B,EAAa1B,EAAAA,QAAO2B,OAAMzB,WAAA,CAAAC,YAAA,+BAAAC,YAAA,gBAAbJ,CAAa,qGAIxBM,EAAAA,EAAOG,SAASmB,OAGzBC,GAA4BC,EAAAA,EAAAA,KAAG,qMAEpBxB,EAAAA,EAAOK,WAAWoB,MACxBzB,EAAAA,EAAOC,MAAMyB,QAON1B,EAAAA,EAAO2B,WAAWC,QACZ5B,EAAAA,EAAOC,MAAMyB,QACxB1B,EAAAA,EAAOC,MAAM4B,YAQbC,GAAmBpC,EAAAA,EAAAA,SAAOqC,EAAAA,GAAKnC,WAAA,CAAAC,YAAA,qCAAAC,YAAA,gBAAZJ,CAAY,kDACxC6B,GAQSS,GAAetC,EAAAA,EAAAA,SAAOqC,EAAAA,GAAKnC,WAAA,CAAAC,YAAA,iCAAAC,YAAA,gBAAZJ,CAAY,iDACpC6B,G,cC7DG,MAAMU,EAAwCC,IAQ9C,IAR+C,MACpDC,EAAK,KACL/I,EAAI,SACJgJ,EAAQ,SACRC,EAAQ,aACRC,EAAY,SACZC,KACGC,GACJN,EACC,OACEO,EAAAA,cAACC,EAAAA,EAAeF,EACdC,EAAAA,cAACE,EAAW,KACVF,EAAAA,cAACE,EAAc,KAAEP,GACjBK,EAAAA,cAACE,EAAW,KAAER,GACdM,EAAAA,cAACE,EAAU,MAAEvD,EAAAA,EAAAA,GAAchG,IAC3BqJ,EAAAA,cAACE,EAAc,CAACC,wBAAyB,CAAEC,OAAQR,KACnDI,EAAAA,cAACE,EAAY,KACVL,GACCG,EAAAA,cAACE,EAAkB,CAACG,GAAIR,GACtBG,EAAAA,cAAA,YAAM,KAAQ,YAIjBF,GACCE,EAAAA,cAACE,EAAc,CAACG,GAAIP,GAAU,OAE5BE,EAAAA,cAAA,YAAM,UCzCdM,EAAU,CAAC,WAAY,QAOhBC,EAAmBC,IAC9B,GALgBC,EAKFD,GAJPF,EAAQI,SAASD,GAKtB,MAAO,UANOA,MAShB,OAAQD,GACN,IAAK,WACH,MAAO,WACT,IAAK,OACH,MAAO,S,cCkDb,MApC0Cf,IAAuB,IAAtB,KAAEkB,KAASZ,GAAMN,EAC1D,MAAM,eAAEmB,EAAc,kBAAEC,GAAsBF,GACxC,YAAEG,EAAW,KAAEC,GAASH,EAExBI,EAAaF,EAAYG,KAAK5K,MAAM,KAAK,GAEzC6K,EAAQL,EAAkBM,MAC7BC,IAAKC,GAASA,EAAKC,KAAKR,YAAYG,MACpCM,OAAQN,GAASA,EAAK5K,MAAM,KAAK,KAAO2K,GACrCnB,EAAeqB,EAAMA,EAAMM,QAAQV,EAAYG,MAAQ,GACvDnB,EAAWoB,EAAMA,EAAMM,QAAQV,EAAYG,MAAQ,GAEnDtB,EAAWY,EAAgBS,GAEjC,OACEhB,EAAAA,cAAAA,EAAAA,SAAA,KACEA,EAAAA,cAACyB,EAAAA,EAAG,CACF/B,MAAOoB,EAAYpB,MACnBgC,YAAa,CACX,CAAEC,KAAMhC,EAAUiC,IAAK,IAAIZ,KAC3B,CAAEW,KAAMb,EAAYpB,UAGxBM,EAAAA,cAACR,EAAUpD,OAAAyF,OAAA,GACL9B,EAAI,CACRL,MAAOoB,EAAYpB,MACnB/I,MAAMhB,EAAAA,EAAAA,GAASmL,EAAYnK,MAC3BgJ,SAAUA,EACVC,SAAUmB,EACVlB,aAAcA,EACdC,SAAUA,M,qECpBX,SAAStD,EAAO5G,EAAUkM,GAE/B,OAAO,OAAcA,GAAWlM,EAAUA,EAC5C,C","sources":["webpack://@rmariuzzo/mariuzzo.com/./node_modules/date-fns/parseISO.js","webpack://@rmariuzzo/mariuzzo.com/./node_modules/date-fns/constants.js","webpack://@rmariuzzo/mariuzzo.com/./node_modules/date-fns/_lib/addLeadingZeros.js","webpack://@rmariuzzo/mariuzzo.com/./node_modules/date-fns/isDate.js","webpack://@rmariuzzo/mariuzzo.com/./node_modules/date-fns/isValid.js","webpack://@rmariuzzo/mariuzzo.com/./node_modules/date-fns/formatRFC7231.js","webpack://@rmariuzzo/mariuzzo.com/./node_modules/date-fns/constructFrom.js","webpack://@rmariuzzo/mariuzzo.com/./src/layouts/PostLayout.styles.ts","webpack://@rmariuzzo/mariuzzo.com/./src/layouts/PostLayout.tsx","webpack://@rmariuzzo/mariuzzo.com/./src/utils/blog.ts","webpack://@rmariuzzo/mariuzzo.com/./src/pages/{MarkdownRemark.frontmatter__slug}.tsx","webpack://@rmariuzzo/mariuzzo.com/./node_modules/date-fns/toDate.js"],"sourcesContent":["import {\n  millisecondsInHour,\n  millisecondsInMinute,\n} from \"./constants.js\";\nimport { constructFrom } from \"./constructFrom.js\";\nimport { toDate } from \"./toDate.js\";\n\n/**\n * The {@link parseISO} function options.\n */\n\n/**\n * @name parseISO\n * @category Common Helpers\n * @summary Parse ISO string\n *\n * @description\n * Parse the given string in ISO 8601 format and return an instance of Date.\n *\n * Function accepts complete ISO 8601 formats as well as partial implementations.\n * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601\n *\n * If the argument isn't a string, the function cannot parse the string or\n * the values are invalid, it returns Invalid Date.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param argument - The value to convert\n * @param options - An object with options\n *\n * @returns The parsed date in the local time zone\n *\n * @example\n * // Convert string '2014-02-11T11:30:30' to date:\n * const result = parseISO('2014-02-11T11:30:30')\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert string '+02014101' to date,\n * // if the additional number of digits in the extended year format is 1:\n * const result = parseISO('+02014101', { additionalDigits: 1 })\n * //=> Fri Apr 11 2014 00:00:00\n */\nexport function parseISO(argument, options) {\n  const invalidDate = () => constructFrom(options?.in, NaN);\n\n  const additionalDigits = options?.additionalDigits ?? 2;\n  const dateStrings = splitDateString(argument);\n\n  let date;\n  if (dateStrings.date) {\n    const parseYearResult = parseYear(dateStrings.date, additionalDigits);\n    date = parseDate(parseYearResult.restDateString, parseYearResult.year);\n  }\n\n  if (!date || isNaN(+date)) return invalidDate();\n\n  const timestamp = +date;\n  let time = 0;\n  let offset;\n\n  if (dateStrings.time) {\n    time = parseTime(dateStrings.time);\n    if (isNaN(time)) return invalidDate();\n  }\n\n  if (dateStrings.timezone) {\n    offset = parseTimezone(dateStrings.timezone);\n    if (isNaN(offset)) return invalidDate();\n  } else {\n    const tmpDate = new Date(timestamp + time);\n    const result = toDate(0, options?.in);\n    result.setFullYear(\n      tmpDate.getUTCFullYear(),\n      tmpDate.getUTCMonth(),\n      tmpDate.getUTCDate(),\n    );\n    result.setHours(\n      tmpDate.getUTCHours(),\n      tmpDate.getUTCMinutes(),\n      tmpDate.getUTCSeconds(),\n      tmpDate.getUTCMilliseconds(),\n    );\n    return result;\n  }\n\n  return toDate(timestamp + time + offset, options?.in);\n}\n\nconst patterns = {\n  dateTimeDelimiter: /[T ]/,\n  timeZoneDelimiter: /[Z ]/i,\n  timezone: /([Z+-].*)$/,\n};\n\nconst dateRegex =\n  /^-?(?:(\\d{3})|(\\d{2})(?:-?(\\d{2}))?|W(\\d{2})(?:-?(\\d{1}))?|)$/;\nconst timeRegex =\n  /^(\\d{2}(?:[.,]\\d*)?)(?::?(\\d{2}(?:[.,]\\d*)?))?(?::?(\\d{2}(?:[.,]\\d*)?))?$/;\nconst timezoneRegex = /^([+-])(\\d{2})(?::?(\\d{2}))?$/;\n\nfunction splitDateString(dateString) {\n  const dateStrings = {};\n  const array = dateString.split(patterns.dateTimeDelimiter);\n  let timeString;\n\n  // The regex match should only return at maximum two array elements.\n  // [date], [time], or [date, time].\n  if (array.length > 2) {\n    return dateStrings;\n  }\n\n  if (/:/.test(array[0])) {\n    timeString = array[0];\n  } else {\n    dateStrings.date = array[0];\n    timeString = array[1];\n    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {\n      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];\n      timeString = dateString.substr(\n        dateStrings.date.length,\n        dateString.length,\n      );\n    }\n  }\n\n  if (timeString) {\n    const token = patterns.timezone.exec(timeString);\n    if (token) {\n      dateStrings.time = timeString.replace(token[1], \"\");\n      dateStrings.timezone = token[1];\n    } else {\n      dateStrings.time = timeString;\n    }\n  }\n\n  return dateStrings;\n}\n\nfunction parseYear(dateString, additionalDigits) {\n  const regex = new RegExp(\n    \"^(?:(\\\\d{4}|[+-]\\\\d{\" +\n      (4 + additionalDigits) +\n      \"})|(\\\\d{2}|[+-]\\\\d{\" +\n      (2 + additionalDigits) +\n      \"})$)\",\n  );\n\n  const captures = dateString.match(regex);\n  // Invalid ISO-formatted year\n  if (!captures) return { year: NaN, restDateString: \"\" };\n\n  const year = captures[1] ? parseInt(captures[1]) : null;\n  const century = captures[2] ? parseInt(captures[2]) : null;\n\n  // either year or century is null, not both\n  return {\n    year: century === null ? year : century * 100,\n    restDateString: dateString.slice((captures[1] || captures[2]).length),\n  };\n}\n\nfunction parseDate(dateString, year) {\n  // Invalid ISO-formatted year\n  if (year === null) return new Date(NaN);\n\n  const captures = dateString.match(dateRegex);\n  // Invalid ISO-formatted string\n  if (!captures) return new Date(NaN);\n\n  const isWeekDate = !!captures[4];\n  const dayOfYear = parseDateUnit(captures[1]);\n  const month = parseDateUnit(captures[2]) - 1;\n  const day = parseDateUnit(captures[3]);\n  const week = parseDateUnit(captures[4]);\n  const dayOfWeek = parseDateUnit(captures[5]) - 1;\n\n  if (isWeekDate) {\n    if (!validateWeekDate(year, week, dayOfWeek)) {\n      return new Date(NaN);\n    }\n    return dayOfISOWeekYear(year, week, dayOfWeek);\n  } else {\n    const date = new Date(0);\n    if (\n      !validateDate(year, month, day) ||\n      !validateDayOfYearDate(year, dayOfYear)\n    ) {\n      return new Date(NaN);\n    }\n    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));\n    return date;\n  }\n}\n\nfunction parseDateUnit(value) {\n  return value ? parseInt(value) : 1;\n}\n\nfunction parseTime(timeString) {\n  const captures = timeString.match(timeRegex);\n  if (!captures) return NaN; // Invalid ISO-formatted time\n\n  const hours = parseTimeUnit(captures[1]);\n  const minutes = parseTimeUnit(captures[2]);\n  const seconds = parseTimeUnit(captures[3]);\n\n  if (!validateTime(hours, minutes, seconds)) {\n    return NaN;\n  }\n\n  return (\n    hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1000\n  );\n}\n\nfunction parseTimeUnit(value) {\n  return (value && parseFloat(value.replace(\",\", \".\"))) || 0;\n}\n\nfunction parseTimezone(timezoneString) {\n  if (timezoneString === \"Z\") return 0;\n\n  const captures = timezoneString.match(timezoneRegex);\n  if (!captures) return 0;\n\n  const sign = captures[1] === \"+\" ? -1 : 1;\n  const hours = parseInt(captures[2]);\n  const minutes = (captures[3] && parseInt(captures[3])) || 0;\n\n  if (!validateTimezone(hours, minutes)) {\n    return NaN;\n  }\n\n  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);\n}\n\nfunction dayOfISOWeekYear(isoWeekYear, week, day) {\n  const date = new Date(0);\n  date.setUTCFullYear(isoWeekYear, 0, 4);\n  const fourthOfJanuaryDay = date.getUTCDay() || 7;\n  const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;\n  date.setUTCDate(date.getUTCDate() + diff);\n  return date;\n}\n\n// Validation functions\n\n// February is null to handle the leap year (using ||)\nconst daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\nfunction isLeapYearIndex(year) {\n  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);\n}\n\nfunction validateDate(year, month, date) {\n  return (\n    month >= 0 &&\n    month <= 11 &&\n    date >= 1 &&\n    date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28))\n  );\n}\n\nfunction validateDayOfYearDate(year, dayOfYear) {\n  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);\n}\n\nfunction validateWeekDate(_year, week, day) {\n  return week >= 1 && week <= 53 && day >= 0 && day <= 6;\n}\n\nfunction validateTime(hours, minutes, seconds) {\n  if (hours === 24) {\n    return minutes === 0 && seconds === 0;\n  }\n\n  return (\n    seconds >= 0 &&\n    seconds < 60 &&\n    minutes >= 0 &&\n    minutes < 60 &&\n    hours >= 0 &&\n    hours < 25\n  );\n}\n\nfunction validateTimezone(_hours, minutes) {\n  return minutes >= 0 && minutes <= 59;\n}\n\n// Fallback for modularized imports:\nexport default parseISO;\n","/**\n * @module constants\n * @summary Useful constants\n * @description\n * Collection of useful date constants.\n *\n * The constants could be imported from `date-fns/constants`:\n *\n * ```ts\n * import { maxTime, minTime } from \"./constants/date-fns/constants\";\n *\n * function isAllowedTime(time) {\n *   return time <= maxTime && time >= minTime;\n * }\n * ```\n */\n\n/**\n * @constant\n * @name daysInWeek\n * @summary Days in 1 week.\n */\nexport const daysInWeek = 7;\n\n/**\n * @constant\n * @name daysInYear\n * @summary Days in 1 year.\n *\n * @description\n * How many days in a year.\n *\n * One years equals 365.2425 days according to the formula:\n *\n * > Leap year occurs every 4 years, except for years that are divisible by 100 and not divisible by 400.\n * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days\n */\nexport const daysInYear = 365.2425;\n\n/**\n * @constant\n * @name maxTime\n * @summary Maximum allowed time.\n *\n * @example\n * import { maxTime } from \"./constants/date-fns/constants\";\n *\n * const isValid = 8640000000000001 <= maxTime;\n * //=> false\n *\n * new Date(8640000000000001);\n * //=> Invalid Date\n */\nexport const maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;\n\n/**\n * @constant\n * @name minTime\n * @summary Minimum allowed time.\n *\n * @example\n * import { minTime } from \"./constants/date-fns/constants\";\n *\n * const isValid = -8640000000000001 >= minTime;\n * //=> false\n *\n * new Date(-8640000000000001)\n * //=> Invalid Date\n */\nexport const minTime = -maxTime;\n\n/**\n * @constant\n * @name millisecondsInWeek\n * @summary Milliseconds in 1 week.\n */\nexport const millisecondsInWeek = 604800000;\n\n/**\n * @constant\n * @name millisecondsInDay\n * @summary Milliseconds in 1 day.\n */\nexport const millisecondsInDay = 86400000;\n\n/**\n * @constant\n * @name millisecondsInMinute\n * @summary Milliseconds in 1 minute\n */\nexport const millisecondsInMinute = 60000;\n\n/**\n * @constant\n * @name millisecondsInHour\n * @summary Milliseconds in 1 hour\n */\nexport const millisecondsInHour = 3600000;\n\n/**\n * @constant\n * @name millisecondsInSecond\n * @summary Milliseconds in 1 second\n */\nexport const millisecondsInSecond = 1000;\n\n/**\n * @constant\n * @name minutesInYear\n * @summary Minutes in 1 year.\n */\nexport const minutesInYear = 525600;\n\n/**\n * @constant\n * @name minutesInMonth\n * @summary Minutes in 1 month.\n */\nexport const minutesInMonth = 43200;\n\n/**\n * @constant\n * @name minutesInDay\n * @summary Minutes in 1 day.\n */\nexport const minutesInDay = 1440;\n\n/**\n * @constant\n * @name minutesInHour\n * @summary Minutes in 1 hour.\n */\nexport const minutesInHour = 60;\n\n/**\n * @constant\n * @name monthsInQuarter\n * @summary Months in 1 quarter.\n */\nexport const monthsInQuarter = 3;\n\n/**\n * @constant\n * @name monthsInYear\n * @summary Months in 1 year.\n */\nexport const monthsInYear = 12;\n\n/**\n * @constant\n * @name quartersInYear\n * @summary Quarters in 1 year\n */\nexport const quartersInYear = 4;\n\n/**\n * @constant\n * @name secondsInHour\n * @summary Seconds in 1 hour.\n */\nexport const secondsInHour = 3600;\n\n/**\n * @constant\n * @name secondsInMinute\n * @summary Seconds in 1 minute.\n */\nexport const secondsInMinute = 60;\n\n/**\n * @constant\n * @name secondsInDay\n * @summary Seconds in 1 day.\n */\nexport const secondsInDay = secondsInHour * 24;\n\n/**\n * @constant\n * @name secondsInWeek\n * @summary Seconds in 1 week.\n */\nexport const secondsInWeek = secondsInDay * 7;\n\n/**\n * @constant\n * @name secondsInYear\n * @summary Seconds in 1 year.\n */\nexport const secondsInYear = secondsInDay * daysInYear;\n\n/**\n * @constant\n * @name secondsInMonth\n * @summary Seconds in 1 month\n */\nexport const secondsInMonth = secondsInYear / 12;\n\n/**\n * @constant\n * @name secondsInQuarter\n * @summary Seconds in 1 quarter.\n */\nexport const secondsInQuarter = secondsInMonth * 3;\n\n/**\n * @constant\n * @name constructFromSymbol\n * @summary Symbol enabling Date extensions to inherit properties from the reference date.\n *\n * The symbol is used to enable the `constructFrom` function to construct a date\n * using a reference date and a value. It allows to transfer extra properties\n * from the reference date to the new date. It's useful for extensions like\n * [`TZDate`](https://github.com/date-fns/tz) that accept a time zone as\n * a constructor argument.\n */\nexport const constructFromSymbol = Symbol.for(\"constructDateFrom\");\n","export function addLeadingZeros(number, targetLength) {\n  const sign = number < 0 ? \"-\" : \"\";\n  const output = Math.abs(number).toString().padStart(targetLength, \"0\");\n  return sign + output;\n}\n","/**\n * @name isDate\n * @category Common Helpers\n * @summary Is the given value a date?\n *\n * @description\n * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.\n *\n * @param value - The value to check\n *\n * @returns True if the given value is a date\n *\n * @example\n * // For a valid date:\n * const result = isDate(new Date())\n * //=> true\n *\n * @example\n * // For an invalid date:\n * const result = isDate(new Date(NaN))\n * //=> true\n *\n * @example\n * // For some value:\n * const result = isDate('2014-02-31')\n * //=> false\n *\n * @example\n * // For an object:\n * const result = isDate({})\n * //=> false\n */\nexport function isDate(value) {\n  return (\n    value instanceof Date ||\n    (typeof value === \"object\" &&\n      Object.prototype.toString.call(value) === \"[object Date]\")\n  );\n}\n\n// Fallback for modularized imports:\nexport default isDate;\n","import { isDate } from \"./isDate.js\";\nimport { toDate } from \"./toDate.js\";\n\n/**\n * @name isValid\n * @category Common Helpers\n * @summary Is the given date valid?\n *\n * @description\n * Returns false if argument is Invalid Date and true otherwise.\n * Argument is converted to Date using `toDate`. See [toDate](https://date-fns.org/docs/toDate)\n * Invalid Date is a Date, whose time value is NaN.\n *\n * Time value of Date: http://es5.github.io/#x15.9.1.1\n *\n * @param date - The date to check\n *\n * @returns The date is valid\n *\n * @example\n * // For the valid date:\n * const result = isValid(new Date(2014, 1, 31))\n * //=> true\n *\n * @example\n * // For the value, convertible into a date:\n * const result = isValid(1393804800000)\n * //=> true\n *\n * @example\n * // For the invalid date:\n * const result = isValid(new Date(''))\n * //=> false\n */\nexport function isValid(date) {\n  return !((!isDate(date) && typeof date !== \"number\") || isNaN(+toDate(date)));\n}\n\n// Fallback for modularized imports:\nexport default isValid;\n","import { addLeadingZeros } from \"./_lib/addLeadingZeros.js\";\nimport { isValid } from \"./isValid.js\";\nimport { toDate } from \"./toDate.js\";\n\nconst days = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n\nconst months = [\n  \"Jan\",\n  \"Feb\",\n  \"Mar\",\n  \"Apr\",\n  \"May\",\n  \"Jun\",\n  \"Jul\",\n  \"Aug\",\n  \"Sep\",\n  \"Oct\",\n  \"Nov\",\n  \"Dec\",\n];\n\n/**\n * @name formatRFC7231\n * @category Common Helpers\n * @summary Format the date according to the RFC 7231 standard (https://tools.ietf.org/html/rfc7231#section-7.1.1.1).\n *\n * @description\n * Return the formatted date string in RFC 7231 format.\n * The result will always be in UTC timezone.\n *\n * @param date - The original date\n *\n * @returns The formatted date string\n *\n * @throws `date` must not be Invalid Date\n *\n * @example\n * // Represent 18 September 2019 in RFC 7231 format:\n * const result = formatRFC7231(new Date(2019, 8, 18, 19, 0, 52))\n * //=> 'Wed, 18 Sep 2019 19:00:52 GMT'\n */\nexport function formatRFC7231(date) {\n  const _date = toDate(date);\n\n  if (!isValid(_date)) {\n    throw new RangeError(\"Invalid time value\");\n  }\n\n  const dayName = days[_date.getUTCDay()];\n  const dayOfMonth = addLeadingZeros(_date.getUTCDate(), 2);\n  const monthName = months[_date.getUTCMonth()];\n  const year = _date.getUTCFullYear();\n\n  const hour = addLeadingZeros(_date.getUTCHours(), 2);\n  const minute = addLeadingZeros(_date.getUTCMinutes(), 2);\n  const second = addLeadingZeros(_date.getUTCSeconds(), 2);\n\n  // Result variables.\n  return `${dayName}, ${dayOfMonth} ${monthName} ${year} ${hour}:${minute}:${second} GMT`;\n}\n\n// Fallback for modularized imports:\nexport default formatRFC7231;\n","import { constructFromSymbol } from \"./constants.js\";\n\n/**\n * @name constructFrom\n * @category Generic Helpers\n * @summary Constructs a date using the reference date and the value\n *\n * @description\n * The function constructs a new date using the constructor from the reference\n * date and the given value. It helps to build generic functions that accept\n * date extensions.\n *\n * It defaults to `Date` if the passed reference date is a number or a string.\n *\n * Starting from v3.7.0, it allows to construct a date using `[Symbol.for(\"constructDateFrom\")]`\n * enabling to transfer extra properties from the reference date to the new date.\n * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n *\n * @param date - The reference date to take constructor from\n * @param value - The value to create the date\n *\n * @returns Date initialized using the given date and value\n *\n * @example\n * import { constructFrom } from \"./constructFrom/date-fns\";\n *\n * // A function that clones a date preserving the original type\n * function cloneDate<DateType extends Date>(date: DateType): DateType {\n *   return constructFrom(\n *     date, // Use constructor from the given date\n *     date.getTime() // Use the date value to create a new date\n *   );\n * }\n */\nexport function constructFrom(date, value) {\n  if (typeof date === \"function\") return date(value);\n\n  if (date && typeof date === \"object\" && constructFromSymbol in date)\n    return date[constructFromSymbol](value);\n\n  if (date instanceof Date) return new date.constructor(value);\n\n  return new Date(value);\n}\n\n// Fallback for modularized imports:\nexport default constructFrom;\n","import styled, { css } from 'styled-components'\n\nimport { PageTitle, TextBlock } from '../components/Typography'\nimport { Link } from '../components/Link'\nimport { $theme } from '../styles/theme'\nimport { theme } from '../theme'\n\nexport const Container = styled.div``\n\nexport const PostCategory = styled.div`\n  display: block;\n  color: ${$theme.color.secondary};\n  text-align: center;\n  margin: 1rem 0;\n  font-size: ${$theme.fontSize.l3}rem;\n  font-weight: ${$theme.fontWeight.light};\n\n  ${theme.breakpoints.up('lg')} {\n    font-size: ${$theme.fontSize.l2}rem;\n    margin: 2rem 0;\n  }\n\n  ${theme.breakpoints.up('xl')} {\n    margin: 3rem 0;\n  }\n`\n\nexport const PostTitle = styled(PageTitle)``\n\nexport const PostDate = styled.small`\n  display: block;\n  text-align: center;\n  color: ${$theme.color.copyLight};\n`\n\nexport const PostContents = styled(TextBlock).attrs({\n  as: 'article'\n})``\n\nexport const PostFooter = styled.footer`\n  display: grid;\n  grid-template-columns: max-content 1fr max-content;\n  margin-top: 2rem;\n  font-size: ${$theme.fontSize.copy1}rem;\n`\n\nconst previousAndNextLinkStyles = css`\n  text-decoration: none;\n  font-weight: ${$theme.fontWeight.black};\n  color: ${$theme.color.primary};\n\n  &:hover > span {\n    opacity: 1;\n  }\n\n  > span {\n    transition: ${$theme.transition.default};\n    background-color: ${$theme.color.primary};\n    color: ${$theme.color.background};\n    display: inline-block;\n    padding: 0.5em;\n    border-radius: 1px;\n    opacity: 0.5;\n  }\n`\n\nexport const PreviousPostLink = styled(Link)`\n  ${previousAndNextLinkStyles};\n  grid-column: 1;\n\n  > span {\n    margin-right: 0.3em;\n  }\n`\n\nexport const NextPostLink = styled(Link)`\n  ${previousAndNextLinkStyles};\n  grid-column: 3;\n\n  > span {\n    margin-left: 0.3em;\n  }\n`\n","import * as React from 'react'\nimport { formatRFC7231 } from 'date-fns'\n\nimport * as S from './PostLayout.styles'\nimport { MainLayout } from './MainLayout'\n\ntype PostLayoutProps = {\n  title: string\n  date: Date\n  category: string\n  contents: any\n  previousSlug: string\n  nextSlug: string\n}\n\nexport const PostLayout: React.FC<PostLayoutProps> = ({\n  title,\n  date,\n  category,\n  contents,\n  previousSlug,\n  nextSlug,\n  ...more\n}) => {\n  return (\n    <MainLayout {...more}>\n      <S.Container>\n        <S.PostCategory>{category}</S.PostCategory>\n        <S.PostTitle>{title}</S.PostTitle>\n        <S.PostDate>{formatRFC7231(date)}</S.PostDate>\n        <S.PostContents dangerouslySetInnerHTML={{ __html: contents }} />\n        <S.PostFooter>\n          {previousSlug && (\n            <S.PreviousPostLink to={previousSlug}>\n              <span>←</span>\n              Previous\n            </S.PreviousPostLink>\n          )}\n          {nextSlug && (\n            <S.NextPostLink to={nextSlug}>\n              Next\n              <span>→</span>\n            </S.NextPostLink>\n          )}\n        </S.PostFooter>\n      </S.Container>\n    </MainLayout>\n  )\n}\n","const blogIds = ['lymphoma', 'code'] as const\ntype BlogId = typeof blogIds[number]\n\nconst isBlogId = (source: any): source is BlogId => {\n  return blogIds.includes(source)\n}\n\nexport const getBlogNameById = (id: string): string => {\n  if (!isBlogId(id)) {\n    return 'General'\n  }\n\n  switch (id) {\n    case 'lymphoma':\n      return 'Lymphoma'\n    case 'code':\n      return 'Code'\n  }\n}\n","import * as React from 'react'\nimport { graphql } from 'gatsby'\nimport { parseISO } from 'date-fns'\n\nimport { PostLayout } from '../layouts/PostLayout'\nimport { getBlogNameById } from '../utils/blog'\nimport { SEO } from '../components/SEO'\n\ntype TemplateProps = {\n  data: {\n    markdownRemark: {\n      html: string\n      frontmatter: {\n        date: string\n        slug: string\n        title: string\n      }\n    }\n    allMarkdownRemark: {\n      edges: Array<{\n        node: {\n          frontmatter: {\n            slug: string\n          }\n        }\n      }>\n    }\n  }\n}\n\nconst Template: React.FC<TemplateProps> = ({ data, ...more }) => {\n  const { markdownRemark, allMarkdownRemark } = data\n  const { frontmatter, html } = markdownRemark\n\n  const categoryId = frontmatter.slug.split('/')[1]\n\n  const slugs = allMarkdownRemark.edges\n    .map((edge) => edge.node.frontmatter.slug)\n    .filter((slug) => slug.split('/')[1] === categoryId)\n  const previousSlug = slugs[slugs.indexOf(frontmatter.slug) - 1]\n  const nextSlug = slugs[slugs.indexOf(frontmatter.slug) + 1]\n\n  const category = getBlogNameById(categoryId)\n\n  return (\n    <>\n      <SEO\n        title={frontmatter.title}\n        breadcrumbs={[\n          { name: category, url: `/${categoryId}` },\n          { name: frontmatter.title }\n        ]}\n      />\n      <PostLayout\n        {...more}\n        title={frontmatter.title}\n        date={parseISO(frontmatter.date)}\n        category={category}\n        contents={html}\n        previousSlug={previousSlug}\n        nextSlug={nextSlug}\n      />\n    </>\n  )\n}\n\nexport default Template\n\nexport const pageQuery = graphql`\n  query ($id: String!) {\n    markdownRemark(id: { eq: $id }) {\n      html\n      frontmatter {\n        date\n        slug\n        title\n      }\n    }\n    allMarkdownRemark(sort: { frontmatter: { date: ASC } }) {\n      edges {\n        node {\n          frontmatter {\n            slug\n          }\n        }\n      }\n    }\n  }\n`\n","import { constructFrom } from \"./constructFrom.js\";\n\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * Starting from v3.7.0, it clones a date using `[Symbol.for(\"constructDateFrom\")]`\n * enabling to transfer extra properties from the reference date to the new date.\n * It's useful for extensions like [`TZDate`](https://github.com/date-fns/tz)\n * that accept a time zone as a constructor argument.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n *\n * @typeParam DateType - The `Date` type, the function operates on. Gets inferred from passed arguments. Allows to use extensions like [`UTCDate`](https://github.com/date-fns/utc).\n * @typeParam ResultDate - The result `Date` type, it is the type returned from the context function if it is passed, or inferred from the arguments.\n *\n * @param argument - The value to convert\n *\n * @returns The parsed date in the local time zone\n *\n * @example\n * // Clone the date:\n * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert the timestamp to date:\n * const result = toDate(1392098430000)\n * //=> Tue Feb 11 2014 11:30:30\n */\nexport function toDate(argument, context) {\n  // [TODO] Get rid of `toDate` or `constructFrom`?\n  return constructFrom(context || argument, argument);\n}\n\n// Fallback for modularized imports:\nexport default toDate;\n"],"names":["parseISO","argument","options","invalidDate","in","NaN","additionalDigits","dateStrings","dateString","array","split","patterns","dateTimeDelimiter","timeString","length","test","date","timeZoneDelimiter","substr","token","timezone","exec","time","replace","splitDateString","parseYearResult","regex","RegExp","captures","match","year","restDateString","parseInt","century","slice","parseYear","Date","dateRegex","isWeekDate","dayOfYear","parseDateUnit","month","day","week","dayOfWeek","_year","validateWeekDate","isoWeekYear","setUTCFullYear","fourthOfJanuaryDay","getUTCDay","diff","setUTCDate","getUTCDate","dayOfISOWeekYear","daysInMonths","isLeapYearIndex","validateDate","validateDayOfYearDate","Math","max","parseDate","isNaN","timestamp","offset","timeRegex","hours","parseTimeUnit","minutes","seconds","validateTime","parseTime","tmpDate","result","setFullYear","getUTCFullYear","getUTCMonth","setHours","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","timezoneString","timezoneRegex","sign","_hours","validateTimezone","parseTimezone","value","parseFloat","pow","millisecondsInMinute","millisecondsInHour","minutesInMonth","minutesInDay","constructFromSymbol","Symbol","for","addLeadingZeros","number","targetLength","abs","toString","padStart","isDate","Object","prototype","call","isValid","toDate","days","months","formatRFC7231","_date","RangeError","constructFrom","constructor","Container","styled","div","withConfig","displayName","componentId","PostCategory","$theme","color","secondary","fontSize","l3","fontWeight","light","theme","breakpoints","up","l2","PostTitle","PageTitle","PostDate","small","copyLight","PostContents","TextBlock","attrs","as","PostFooter","footer","copy1","previousAndNextLinkStyles","css","black","primary","transition","default","background","PreviousPostLink","Link","NextPostLink","PostLayout","_ref","title","category","contents","previousSlug","nextSlug","more","React","MainLayout","S","dangerouslySetInnerHTML","__html","to","blogIds","getBlogNameById","id","source","includes","data","markdownRemark","allMarkdownRemark","frontmatter","html","categoryId","slug","slugs","edges","map","edge","node","filter","indexOf","SEO","breadcrumbs","name","url","assign","context"],"sourceRoot":""}